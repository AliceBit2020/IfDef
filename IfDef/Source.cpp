
	

/*Директивы условной компиляции используются для решения какой участок кода подавать на вход компилятору.
Применяются довольно часто для написания платформозависимого кода, отладочного кода и т.д.

К директивам условной компиляции относят : #if, #else, #elif, #endif, #ifdef, #ifndef
И в дополнение присутствует специальный оператор для препроцессора defined.

Директива #if проверяет выражение, если результат - истина, то заключенный код подается на вход компилятору, если же результат - ложь,
то код не будет подан на вход компилятору.Принцип похож на инструкцию if, с той огромной разницей, что #if (и т.д.)
работает ДО компиляции.Соответственно может проверять только литералы, макросы и макроопределения(#define) и никак не может
работать с объектами этапа выполнения, такими как переменные.

При работе с директивами условной компиляции можно использовать логические операторы, операторы отношений и арифметические операторы.

*/

#include <iostream>
#include"Define.h"

using namespace std;





void TestConditionalCompilation();


int main()
{
	TestConditionalCompilation();
}
void TestConditionalCompilation()
{
	cout << "TestConditionalCompilation()\n\n" << endl;

	// Пример: Участок кода, где присутствуют платформозависимые инструкции, вызов специфических функций и т.д.
	// Под каждую платформу программа будет компилироваться отдельно. А выбор кода, который будет скомпилирован будет зависеть от макроопределения.
	// Достаточно заменить значение макроса OS_SPECIFIC

#if OS_SPECIFIC == LINUX
	{
		cout << "Some linux code\n" << endl;


	}
	
#elif OS_SPECIFIC == WINDOWS // elif аналогично по смыслу с else if
	{

		cout << "Some windows code\n" << endl;


	}
	
#elif OS_SPECIFIC == macOS
	cout << "Some macOS code\n";
#else 
	cout << "Other OS code\n";
#endif	// #endif - обязательно в конце любого блока условной компиляции



	{




		/////загальний участок коду для будьякої опраційної системи
	}



	// Предположим, что необходимо компилировать код только тогда, когда приложение находится в разработке.
	// Например, какой-то код, выводящий отладочную информацию, который совершенно не нужен в итоговой версии приложения.
	// Но удаление этого кода займет время (причем немало)
	// При помощи директив условной компиляции можно проверить был ли вообще определен какой-либо макрос

#define DEBUG

	// Если макрос DEBUG есть, причем его значение не важно - компилируется участок кода
	// Достаточно убрать определение макроса DEBUG, чтобы исключить отладочный код из итоговой версии приложения.
	// Директива #ifdef проверяет макроопределение, если оно есть - код компилируется
#ifdef DEBUG
	cout << "Some debug code here!!" << endl << endl;
#endif

	// Противоположная директива #ifndef (if not defined) - проверяет макроопределение, если его НЕТ - то код компилируется
#ifndef DEBUG
	cout << "ONLY IN RELEASE MODE code" << endl << endl;
#endif

	// Более гибкий оператор defined, предназначенный для использования в директиве #if, на случай если условие более сложное,
	// чем проверка на существование
#if defined(DEBUG) && OS_SPECIFIC == WINDOWS
	cout << "Some debug code here!! Only WINDOWS!" << endl << endl;
#endif


#if !defined(DEBUG) && OS_SPECIFIC == WINDOWS
	cout << "Some RELEASE code here!! Only WINDOWS!" << endl << endl;
#endif

	cout << "=====TestConditionalCompilation end=====\n\n";



	//Директива #undef удаляет текущее определение идентификатора.Следовательно, последующие вхождения идентификатора игнорируются препроцессором.Чтобы удалить определение макроса с помощью #undef, укажите только идентификатормакроса, а не список параметров.
//#define WIDTH 80
//#define ADD( X, Y ) ((X) + (Y))
//	.
//		.
//		.
//#undef WIDTH
//#undef ADD




}
//  https://msdn.microsoft.com/en-us/library/3sxhs2ty.aspx
